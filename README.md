# Kernel machine tests of association between brain networks and phenotypes
Authors:
* Alexandria M Jensen, MS
* Jason R Tregellas, PhD
* Brianne Sutton, PhD
* Fuyong Xing, PhD
* Debashis Ghosh, PhD

## Abstract
Applications of quantitative network analysis to function brain connectivity have become popular in the last decade due to their ability to describe the general topological principles of brain networks. However, many issues arise when standard statistical analysis techniques are applied to functional magnetic resonance imaging (fMRI) connectivity maps. Frequently, summary measures of these maps, such as global efficiency and clustering coefficients, collapse the changing structure of graph topology from many scales to one. This can result in a loss of whole-brain spatio-temporal pattern information that may be significant in association and prediction analyses. Drawing from the electrical engineering field, the resistance perturbation distance is a quantification of similarity between graphs on the same vertex set that has been shown to identify changes in dynamic graphs, such as those from fMRI, while not being computationally expensive or result in a loss of information. This work proposes a novel kernel-based regression scheme that incorporates the resistance perturbation distance to better understand the association with biological phenotypes from fMRI using both simulated and real datasets. 

## Real-World Dataset: COBRE
The real dataset utilized in the accompanying manuscript comes from The Center for Biomedical Research Excellence (COBRE) through the Mind Research Network for Neurodiagnostic Discovery at the University of New Mexico. Raw anatomical and function MR data was provided to the 1000 Functional Connectomes project on 72 subjects with diagnosed schizophrenia and 75 healthy controls. For every subject within this dataset, a resting fMRI dataset, an anatomial MRI scan, and phenotypic data (e.g., age, gender, handedness, and diagnostic information) was provided. In order to download the data, you must be logged into NITRC and registered with the 1000 Functional Connectomes project, which is why the data is not provided in this repository.

For further information, including instructions on how to download the dataset, please visit the following webpage: http://fcon_1000.projects.nitrc.org/indi/retro/cobre.html.

## Simulated fMRI Dataset
As an alternative to utilizing the COBRE dataset, two R datasets have been included in this repository. The simulated_phenotypic_data.RData file contains a simulated dataframe that mimics what is provided in COBRE's phenotypic file for 145 subjects, including age, gender, handedness, and group. Diagnostic information is not provided in this simulated phenotypic dataset as random samples can be used to mimic the subset analysis of the COBRE dataset. As well, the simulated_adj_matrices.RData file contains a simulated array of 145 132x132 ROI correlation matrices. These matrices were simulated using the MNS package and were all simulated under the same function call with a high degree of noise added. Negative correlations within these matrices have not been modified to allow for full use of the COBRE-specific analysis files. 

## Description of R scripts
### Notes
These scripts make some basic assumptions about the structure of the data. Adjacency matrices are assumed to come from weighted, undirected networks. The resistance perturbation distance cannot be calculated on directed networks due to the asymmetry of the adjacency matrices (a requirement for RPD calculation); an unweighted network would result in non-unique RPD values and, thusly, a trivial example. Additionally, the outcome is presumed to be dichotomous. If the outcome variable is categorical or continuous in nature, additional changes to the code, specifically within the score functions, would need to be made.

### Simulation_Functions.R
This script contains all of the functions called within the Full_Simulations.R script.
* The ```fMRI_mimic()``` function takes an nxn symmetric correlation data frame and mimics the adjacency matrix output from an fMRI dataset. It zeros out the diagonal and zeros out any negative correlations, the latter of which is the most common treatment of negative correlations within an fMRI analysis. Output is a data frame of the same dimensions as the original data frame.
* The ```fMRI_mimic2()``` function does the same thing as ```fMRI_mimic``` , except on matrix rather than on a data frame. The output is a matrix of the same dimenions as the input matrix.
* The ```degree()``` function calculates the degree matrix from an nxn symmetric adjacency matrix. Returns an array, ```data_sub```, where ```data_sub[i,1,,]``` denotes the adjacency matrix for subject ```i``` and ```data_sub[i,2,,]``` denotes the degree matrix for subject ```i```.
* The ```resist()``` function calculates the effective resistance for a network using its adjacency and degree matrices. This is placed into an array that is indexed by subject, ```eff_res[i,1,,]```.
* The ```distance()``` function calculates the pairwise resistance perturbation distances (RPDs) between networks using the effective resistance array. The output is a symmetric matrix indexed by subject, where ```RPD_matrix[i,j]``` is the resistance perturbation distance between subjects ```i``` and ```j```.
* The ```kernel()``` and ```invlogit()``` functions are used within the larger ```sim_score``` function. The former creates the kernel K and the latter conducts the inverse logit operation.
* The ```sim_score()``` function takes five inputs: (1) the RPD matrix, x; (2) the group label, y; (3) the lower bound of the grid search, lower; (4)  the upper bound of the grid search, upper; and (5) the granularity of the grid search, m. It conducts a score test to see if the addition of the kernel K, which is built using the RPD matrix, is significantly associated with the group label. The output of this score function is a p-value, from which typical statistical significance can be assessed. The upper and lower bounds of the grid search are found using the ```up_low()``` function.
* The ```up_low()``` function takes in the RPD matrix and finds the upper and lower bounds of the grid search. The output is a data frame of  squared differences. To find the upper bound, the maximum of these squared differences is multiplied by 100; to find the lower bound, the non-zero minimum of these squared differences is multiplied by 0.1.

### Full_Simulations.R
This script will reproduce all of the simulated results from the manuscript. An essential package to these simulations is the MNS package, which is a package for estimating multiple, related networks using the Mixed Neighborhood Selection algorithm, developed by Monti, Anagnostopolous, and Montana. 

Functions within this script are related specifically to testing the assumptions presented in the manuscript. Code related to creation of tables and plots remain for complete transparency for replication of the results within the manuscript and for reproduction in additional simulations.

#### EDGE IMPORTANCE: changes that create disconnected components should be penalized more than changes that maintain the connectivity properties of the graph
* The ```disconnected()``` function created disconnected components within an adjacency matrix by breaking the matrix up into four quadrants, then zeroing out all cells within QI and QIII (the off-diagonal of the quadrants). This function is utilized within the ```edge_importance()``` function. 
* The ```edge_importance()``` function requires inputs related to the number of iterations and to specify the type of network to be created within the ```gen_Network()``` function of the MNS package. The inputs to generate the network have been optimized to mimic simplified fMRI data but can be tailored to fit specific needs. From an original network, it creates two comparison networks: one in which there are disconnected components and one in which components are randomly removed, preserving the global-scale connectivity properties of the network. The RPD is then calculated for each pair of original and modified networks.

#### WEIGHT AWARENESS: in weighted graphs, the larger the weight of the removed edge, the greater the impact on the distance should be
* The ```weight_aware()``` function requires inputs related to the number of iterations and to specify the type of network to be created within the ```gen_Network()``` function of the MNS package. The inputs to generate the network have been optimized to mimic simplified fMRI data but can be tailored to fit specific needs. From an original network, it creates two comparison networks: one in which the largest weighted edge is removed and one in which the smallest, non-zero weighted edge is removed. The RPD is then calculated for each pair of original and modified networks.

#### EDGE 'SUBMODULARITY': a specific change is more important in a graph with few edges than in a much denser, but equally sized graph 
* The ```submod()``` function requires inputs related to the number of iterations and to specify the type of network to be created within the ```gen_Network()``` function of the MNS package. The inputs to generate the network have been optimized to mimic simplified fMRI data but can be tailored to fit specific needs. From an original network, a comparison network is created in which the largest weighted edge is removed. Two function calls need to be made to test this principle: one with a lower sparsity value and one with a higher sparsity value. The RPD is calculated within each of these function calls between the original and modified network.

#### FOCUS AWARENESS: random changes in graphs are less important than targeted changes of the same extent
* The ```targeted_deletion()``` function deletes an all edges from a randomly-selected node. This function was created to reflect the manner in which Koutra et al. tested this principle by comparing removal of all edges from a node to removing the same number of edges randomly from the network.
* The ```focus()``` function requires inputs related to the number of iterations and to specify the type of network to be created within the ```gen_Network()``` function of the MNS package. The inputs to generate the network have been optimized to mimic simplified fMRI data but can be tailored to fit specific needs. From an original network, two comparison networks are created: one in which all edges from a randomly-selected node have been removed and another in which the same number of edges are randomly removed from the network. The RPD is then calculated for each pair of original and modified networks.

#### POWER CALCULATION
* The ```power_sim()``` function requires inputs related to the number of networks to be created as well as specifications related to the type of network to be created within the ```gen_Network()``` function of the MNS package. This function creates three different groups of networks (specified by N1, N2, and N3); the first group acts as the 'control' group, the third as the 'case' group, and the second as a 'noise' group to be dispersed between the case and control groups (specified by x and z). Because the case and control networks are generated under different calls of the ```gen_Network()``` function, they will inherently be different from one another. To simulate the low signal-to-noise ratio within, each of these groups is injected with networks from a third group, generated from a separate ```gen_Network()``` function call. After calculation of all the pairwise RPDs for the totality of these networks, the score function is calculated, with the outcome of interest the group label of 'control' or 'case.' This process is iterated over a pre-specified number of times and power is calculated as the proportion of iterations in which the score function's probability was less than 0.05 (indicating a correct rejection of the null hypothesis).

#### TYPE I ERROR CALCULATION
* The ```type1err_sim()``` function requires inputs related to a binomial probability and specifications related to the type of network to be created within the ```gen_Network()``` function of the MNS package. This function generates all networks from the same function all and then, based on the binomial probability specification, are randomly allocated to either a 'case' or 'control' group. Because all of the networks were generated under the same function call, they will inherently be related to one another. After calculation of all the pairwise RPDs for these networks, the score function is calculated, with the outcome of interest the group label of 'control' or 'case.' This process is iterated over a pre-specified number of times and power is calculated as the proportion of iterations in which the score function's probability was less than 0.05 (indicating an incorrect rejection of the null hypothesis).

#### CONTROL/PATIENT SPLITS
* The ```prob_sim()``` function requires inputs related to random splits of networks generated under a single function call as well as specifications related to the type of networks to be created within the ```gen_Network()``` function of the MNS package. This function will create a grid of probabilities, specified by its lower bound, upper bound, and incremental increase. Based on the probability within a cell of this grid, networks generated by the single function call (and therefore are inherently related to one another) are randomly assigned to the 'case' group. Pairwuse RPDs are calculated for all networks and the score function is calcualted with the outcome of interest the group label of 'control' or 'case.' This process is iterated over the entirety of the probabilty grid to understand the relationship between group size and the resulting p-values of the score function; in this instance, an incorrect rejection of the null hypothesis is of interest.

#### NOISE SPLITS
* The ```noise_sim()``` function requires inputs related to random splits of networks generated under two separate function calls allocation of a noise network between the two groups, and specifications related to the type of networks to be created within the ```gen_Network()``` function of the MNS package. This function creates a grid of probabilities, specified by its lower bound, upper bound, and incremental increase. Three different groups of networks (specified by N1, N2, and N3) are also specified; the first group acts as the 'control' group, the third as the 'case' group, and the second as a 'noise' group to be dispersed between the case and control groups (specified by x and z). Because the case and control networks are generated under different calls of the ```gen_Network()``` function, they will inherently be different from one another. To simulate the low signal-to-noise ratio within, each of these groups is injected with networks from a third group, generated from a separate ```gen_Network()``` function call. The probability grid is used to determine the allocation of the noise networks to the 'control' and 'case' groups. After calculation of all the pairwise RPDs for the totality of these networks, the score function is calculated, with the outcome of interest the group label of 'control' or 'case.' This process is iterated overthe entirety of the probability grid to understand the relationship between noise allocation between groups and the resulting p-values of the score function; in this instance, a correct rejection of the null hypothesis is of interest.

#### BOUNDARIES OF THE SCORE FUNCTION GRID SEARCH
* The ```bounds_one_sim()``` function require inputs related to the bounds of the score function grid search and specifications related to the type of networks to be created within the ```gen_Network()``` function of the MNS package. Within Liu et. al (2007) suggested that the lower bound of the grid search be multiplied by 0.1 while the upper bound be multiplied by 100. This function tests the robustness of the score function to alterations in these multiplicative constants under a one network generation process. The initial lower and upper bounds are specified, then multiplied by 10^(len), where len is determined, a priori, as the length of the lower and upper bound grids. As all of the networks were generated under the same function call, they will inherently be related to one another. After calculation of all the pairwise RPDs for these networks, the score function is calculated, with the outcome of interest the group label of 'control' or 'case.' This process is iterated over a pre-specified number of times and power is calculated as the proportion of iterations in which the score function's probability was less than 0.05 (indicating an incorrect rejection of the null hypothesis).
* The ```bounds_two_sim()``` function is the two generation network analog to the ```bounds_one_sim()``` function. Rather than create all simulated networks from the same function call of ```gen_Network()```, two different groups of networks (specified by N1 and N2) are simulated; the first group acts as the 'control' group and the second as the 'case' group. Because the case and control networks are generated under different calls of the ```gen_Network()``` function, they will inherently be different from one another.After calculation of all the pairwise RPDs for these networks, the score function is calculated, with the outcome of interest the group label of 'control' or 'case.' This process is iterated over a pre-specified number of times and power is calculated as the proportion of iterations in which the score function's probability was less than 0.05 (indicating an correct rejection of the null hypothesis).

### COBRE_Functions.R
This script contains all of the functions called within the COBRE_Full_Analysis.R and COBRE_Paranoid_Analysis.R scripts.
* ```Matlab_fMRI()``` is a function that takes an input of an array filled with adjacency matrices calculated from the CONN toolbox within the MatLab language. It zeros out the diagonal, applies the hyperbolic tangent function (to get back to correlation coefficients rather than z-scores), and zeros out any negative correlations. The output is an array of the same dimensions.
* ```Matlab_fMRI_neg()``` is a function that has the same functionality as ```Matlab_fMRI()``` but keeps the negative correlations as is.
* The ```degree()``` function calculates the degree matrix from an nxn symmetric adjacency matrix. Returns an array, ```data_sub```, where ```data_sub[i,1,,]``` denotes the adjacency matrix for subject ```i``` and ```data_sub[i,2,,]``` denotes the degree matrix for subject ```i```.
* The ```resist()``` function calculates the effective resistance for a network using its adjacency and degree matrices. This is placed into an array that is indexed by subject, ```eff_res[i,1,,]```.
* The ```distance()``` function calculates the pairwise resistance perturbation distances (RPDs) between networks using the effective resistance array. The output is a symmetric matrix indexed by subject, where ```RPD_matrix[i,j]``` is the resistance perturbation distance between subjects ```i``` and ```j```.
* The ```kernel()``` and ```invlogit()``` functions are used within the larger ```sim_score``` function. The former creates the kernel K and the latter conducts the inverse logit operation.
* The ```score()``` function takes five inputs: (1) the RPD matrix, x; (2) the demographics dataset, cobre_v2; (3) the lower bound of the grid search, lower; (4)  the upper bound of the grid search, upper; and (5) the granularity of the grid search, m. It conducts a score test to see if the addition of the kernel K, which is built using the RPD matrix, is significantly associated with the group label, after accounting for subject age, gender, and handedness (the three demographics variables available within the COBRE phenotypic dataset). The output of this score function is a p-value, from which typical statistical significance can be assessed. The upper and lower bounds of the grid search are found using the ```up_low()``` function.
* The ```score_null()``` function takes five inputs: (1) the RPD matrix, x; (2) the demographics dataset, cobre_v2; (3) the lower bound of the grid search, lower; (4)  the upper bound of the grid search, upper; and (5) the granularity of the grid search, m. It conducts a score test to see if the addition of the kernel K, which is built using the RPD matrix, is significantly associated with the group label, without accounting for any demographic variables parametrically. The output of this score function is a p-value, from which typical statistical significance can be assessed. The upper and lower bounds of the grid search are found using the ```up_low()``` function.
* The ```up_low()``` function takes in the RPD matrix and finds the upper and lower bounds of the grid search. The output is a data frame of  squared differences. To find the upper bound, the maximum of these squared differences is multiplied by 100; to find the lower bound, the non-zero minimum of these squared differences is multiplied by 0.1.

### COBRE_Full_Analysis.R
This script provides details on the exact analysis conducted on the entire COBRE dataset. Demographic variables were brought in via a .csv file (the original phenotypic file was provided on a tab of a larger Microsoft Excel workbook that also contained tabs with details on the MPRAGE and fMRI scans). Adjacency matrices were exported from the CONN toolbox as .mat files and then imported into R using the R.matlab package. Four different score tests were conducted based on unique combinations of semiparametric/non-parametric analysis techinque and treatment of negative correlations within the adjaency matrices.

### COBRE_Paranoid_Analysis.R
This script provides details on the exact analysis conducted on an abbreviated COBRE dataset that included only cases with a diagnosis of paranoid schizophrenia and a random sample of controls. Demographic variables were brought in via a .csv file (the original phenotypic file was provided on a tab of a larger Microsoft Excel workbook that also contained tabs with details on the MPRAGE and fMRI scans). Adjacency matrices were exported from the CONN toolbox as .mat files and then imported into R using the R.matlab package. Four different score tests were conducted based on unique combinations of semiparametric/non-parametric analysis techinque and treatment of negative correlations within the adjaency matrices.

### COBRE_Add_Analysis.R
This script provides details on the exact analysis conducted comparing the score function developed in the accompanying manuscript with other graph theoretic measures commonly used in functional connectivity analyses: global efficiency and rich club coefficient. These comparisons were made on the full COBRE dataset and on the paranoid schizophrenia subset.Demographic variables were brought in via a .csv file (the original phenotypic file was provided on a tab of a larger Microsoft Excel workbook that also contained tabs with details on the MPRAGE and fMRI scans). Adjacency matrices were exported from the CONN toolbox as .mat files and then imported into R using the R.matlab package. Gobal efficiency and rich club coefficents were calculated using the iGraph package. For each dataset, the same four score tests were conducted as detailed above.

### Correlation_Heat_Maps.R
This script provdes details on the creation of the correlation heat maps within the manuscript. After bringing the .mat files in an array, negative correlations are either zeroed out or are kept as is within the matrices. Utilizing the ```ggplot()``` function in addition to the ```scale_fill_gradient()``` option, a heat map is created, showing the correlation in BOLD time series between each pair of (numbered) regions of interest. These heat maps are stratified by group label within the COBRE dataset and are created for the full dataset as well as the paranoid schizophrenia subset.